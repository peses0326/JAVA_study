## 추상클래스와 추상메서드
**추상클래스 (abstract class)**

> 제어자 중에서 abstract라는 것이 있었다.이 제어자가 클래스 앞에 붙으면 추상클래스가 된다.추상클래스가 무엇이며, 사용하는 이유는 무엇인가?

**추상클래스**

클래스를 설계도에 비유한다면, 추상클래스는 **미완성 설계도**에 비유할 수 있다.

단어 뜻 그대로 완성되지 못한 채로 남겨진 설계도를 말한다.

미완성 메서드(추상메서드)를 포함하고 있다는 의미이다,

추상메서드를 포함하고 있다는 것을 제외하고는 일반 클래스와 전혀 다르지 않다.

추상클래스는 그 자체로 클래스 역할을 다 하지 못하지만,

새로운 클래스를 작성하는데 있어서 바탕이 되는 조상클래스로서의 중요한 역할을 한다.

**추상메서드(abstract Method)**

메서드는 선언부와 구현부로 구성되어 있다.

추상메서드란 선언부만 작성하고 **구현부는 작성하지 않은 채로 남겨 둔 것**이 추상메서드이다,

실제 내용은 상속받는 클래스에서 구현하도록 비워둔 것이다.

추상메서드 역시 키워드 **'abstract'**를 앞에 붙여주고, 구현부가 위치할 { }대신 마침을 의미하는 ; 을 작성한다.

!만일, 조상으로부터 상속받은 추상메서드 중 하나라도 구현하지 않는다면, 추상클래스로 지정해주어야 한다.

**왜 추상클래스를 사용하는가?**

자손 클래스에서 추상메서드를 반드시 구현하도록 강요하기 위해서이다.

상속받는 자손클래스에서는 메서드들이 완전히 구현된 것으로 인식하고

오버라이딩을 하지 않을 수 있기 때문이다.

```java
abstract class Animal{
  **int** age;
  abstract **void** move(**int** x, **int** y); //x,y까지 이동하는 메서드
  
  abstract **void** speak(); //소리를 내는 메서드

  **void** stop(){
    //정지
  }
}
```

Animal이라는 추상클래스를 정의하고,

추상 메서드 2개를 정의했다.

```java
class Person **extends** Animal{
  **void** move(**int** x, **int** y){
    //두 발로 걸어서 이동
  }

  **void** speak(){
    //말한다.
  }
}
```

Animal Class를 상속받는 Person 클래스를 정의하고,

```java
class Dog **extends** Animal{
  **void** move(**int** x, **int** y){
    //네 발로 이동
  }

  **void** speak(){
    //짖는다.
  }
}
```

Animal Class를 상속받는 Person 클래스를 정의했다.

두 클래스 모두 추상 메서드를 생성되는 인스턴스의 특성에 맞게 두 가지 모두 구현했다.

```java
abstract class Cat **extends** Animal{
  **void** move(**int** x, **int** y){
    //네 발로 이동
  }
}
```

이번엔 Animal Class를 상속받는 Cat 클래스를 정의했다.

speak( )메서드를 구현하지 않았으므로, abstract 키워드를 붙여줘야 한다.

사실 순서상 메소드의 추상화가 먼저이다.

추상화된 메소드를 설정하기 위해서는 그 메소드를 담고 있는 클래스는 abstract 해줘야 한다.

하나라도 추상 메소드를 포함해야 한다면 클래스는 추상 클래스이어야 한다.

물론 이 의미에서 추상 클래스는 추상 메소드가 아닌 메소드를 포함할 수 있다.

맥락에 따라서 달라질 수 있는 기능들이 있을 때, 추상 메소드로 만든다.

추상 클래스로 정의를 한 다음에,,

달라질 가능성이 없는 부분에 대해서는 일반 메소드로 작성을 하고

달라질 가능성이 존재하는 메소드에 대해서는 추상 메소드로 정의를 해준다.

이렇게 되면 사용자의 입장에서 추상 메소드에 대한 부분을 직접 정의하여

상황에 맞게 클래스를 사용할 수 있다.

이 또한 코드의 중복을 막기 위한 일환이라고 볼 수 있다.

자바는 객체지향 언어이고, 탄생의 목적으로 모든 문법이 귀결된다고 볼 수 있다.

탄생 목적은 코드 재사용성을 높이자. 즉 '중복되는 코드를 없애자'인 것이다.

이번 abstract 문법도 그 목적의 일환으로서 이해를 한다면 좀 더 쉽게 다가올 수 있다.)
